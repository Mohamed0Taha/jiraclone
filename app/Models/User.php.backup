<?php

namespace App\Models;

use App\Notifications\CustomVerifyEmail;
use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Cashier\Billable;
use Laravel\Sanctum\HasApiTokens;

class User extends Authenticatable implements MustVerifyEmail
{
    use Billable, HasApiTokens, HasFactory, Notifiable;

    protected $fillable = [
        'name', 'email', 'password',
        'google_id', 'google_avatar', 'google_token', 'google_refresh_token',
        'trial_used', 'trial_plan', 'ai_tasks_used', 'usage_reset_date',
    ];

    protected $hidden = ['password', 'remember_token'];

    protected function casts(): array
    {
        return [
            'email_verified_at' => 'datetime',
            'password' => 'hashed',
            'trial_ends_at' => 'datetime',
            'trial_used' => 'boolean',
            'usage_reset_date' => 'date',
        ];
    }

    /**
     * Send the custom email verification notification (relative-signed URL).
     */
    public function sendEmailVerificationNotification(): void
    {
        $this->notify(new CustomVerifyEmail);
    }

    public function projects()
    {
        return $this->hasMany(Project::class);
    }

    public function memberProjects()
    {
        return $this->belongsToMany(Project::class, 'project_members')
            ->withPivot('role', 'joined_at')
            ->withTimestamps();
    }

    public function invitations()
    {
        return $this->hasMany(ProjectInvitation::class, 'email', 'email');
    }

    public function pendingInvitations()
    {
        return $this->hasMany(ProjectInvitation::class, 'email', 'email')
            ->where('status', 'pending');
    }

    public function onPro(): bool
    {
        return $this->subscribed('default') || $this->onTrial('default');
    }

    public function onTrial(string $subscription = 'default'): bool
    {
        $subscription = $this->subscription($subscription);

        return $subscription && $subscription->onTrial();
    }

    public function hasActiveSubscription(): bool
    {
        return $this->subscribed('default') || $this->onTrial('default');
    }

    /**
     * Get the user's current plan name
     */
    public function getCurrentPlan(): string
    {
        $subscription = $this->subscription('default');

        if ($subscription) {
            return $this->getPlanFromPriceId($subscription->stripe_price);
        } elseif ($this->onTrial('default')) {
            return $this->trial_plan ?? 'basic';
        }

        return 'free';
    }

    /**
     * Check if user can access a premium feature
     */
    public function canAccessFeature(string $feature): bool
    {
        if (! $this->hasActiveSubscription()) {
            return false;
        }

        $plan = $this->getCurrentPlan();

        switch ($feature) {
            case 'ai_task_generation':
                return in_array($plan, ['basic', 'pro', 'business']);
            case 'automation':
                return in_array($plan, ['pro', 'business']);
            case 'members':
                return in_array($plan, ['pro', 'business']);
            case 'reports':
                return in_array($plan, ['basic', 'pro', 'business']);
            case 'ai_assistant':
                return in_array($plan, ['basic', 'pro', 'business']);
            default:
                return true;
        }
    }

    /**
     * Get AI task generation limit for current plan
     */
    public function getAiTaskLimit(): int
    {
        $plan = $this->getCurrentPlan();

        $limits = [
            'basic' => 25,
            'pro' => 50,
            'business' => 200,
        ];

        return $limits[$plan] ?? 0;
    }

    /**
     * Get remaining AI task generation count
     */
    public function getRemainingAiTasks(): int
    {
        $this->resetUsageIfNeeded();

        $limit = $this->getAiTaskLimit();
        $used = $this->ai_tasks_used ?? 0;

        return max(0, $limit - $used);
    }

    /**
     * Increment AI task usage
     */
    public function incrementAiTaskUsage(int $count = 1): bool
    {
        $this->resetUsageIfNeeded();

        if ($this->getRemainingAiTasks() >= $count) {
            $this->increment('ai_tasks_used', $count);

            return true;
        }

        return false;
    }

    /**
     * Check if user can generate AI tasks
     */
    public function canGenerateAiTasks(int $count = 1): bool
    {
        if (! $this->hasActiveSubscription()) {
            return false;
        }

        return $this->getRemainingAiTasks() >= $count;
    }

    /**
     * Reset usage tracking if needed (monthly reset)
     */
    private function resetUsageIfNeeded(): void
    {
        $resetDate = $this->usage_reset_date;
        $now = now()->startOfDay();

        // If no reset date set, set it to beginning of current month
        if (! $resetDate) {
            $this->update([
                'usage_reset_date' => $now->firstOfMonth(),
                'ai_tasks_used' => 0,
            ]);

            return;
        }

        // If we've passed into a new month, reset usage
        if ($now->firstOfMonth()->isAfter($resetDate)) {
            $this->update([
                'usage_reset_date' => $now->firstOfMonth(),
                'ai_tasks_used' => 0,
            ]);
        }
    }

    /**
     * Get plan name from Stripe price ID
     */
    private function getPlanFromPriceId(string $priceId): string
    {
        $plans = config('subscriptions.plans');

        foreach ($plans as $key => $plan) {
            if ($plan['price_id'] === $priceId) {
                return $key;
            }
        }

        return 'basic'; // fallback
    }
}
