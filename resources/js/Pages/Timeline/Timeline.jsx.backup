// resources/js/Pages/Timeline/Timeline.jsx
import React, { useState, useCallback, useEffect, useMemo } from 'react';
import { Head } from '@inertiajs/react';
import AuthenticatedLayout from '@/Layouts/AuthenticatedLayout';
import {
    Box, Typography, Paper, Container, Button,
    IconButton, Chip, Card, CardContent, useTheme, alpha,
    Avatar, AvatarGroup, ButtonGroup, Divider, Zoom, Fade, Tooltip
} from '@mui/material';
import {
    CalendarToday as CalendarIcon,
    ViewWeek as WeekIcon,
    ViewModule as MonthIcon,
    Lock as LockIcon,
    LockOpen as LockOpenIcon,
    DragIndicator as DragIndicatorIcon,
    ArrowBack as ArrowBackIcon,
    Today as TodayIcon,
    ViewWeek as ViewWeekIcon,
    CalendarMonth as ViewMonthIcon,
    ZoomIn as ZoomInIcon,
    ZoomOut as ZoomOutIcon,
    Schedule as ScheduleIcon,
    CheckCircle as CheckCircleIcon
} from '@mui/icons-material';
import Timeline, {
    TimelineHeaders,
    SidebarHeader,
    DateHeader
} from 'react-calendar-timeline';
// Timeline CSS imported in app.jsx
import moment from 'moment';
import axios from 'axios';
import { METHODOLOGIES, DEFAULT_METHOD, getStatusMeta, getStatusOrder } from '@/Pages/Board/meta';
import { usePage, router } from '@inertiajs/react';
import { route } from 'ziggy-js';

export default function TimelinePage({ auth, project = {}, tasks = {}, users = [] }) {
    const { props } = usePage();
    const authenticatedUser = auth || props?.auth || {};
    const theme = useTheme();
    const [visibleTimeStart, setVisibleTimeStart] = useState(moment().startOf('week').valueOf());
    const [visibleTimeEnd, setVisibleTimeEnd] = useState(moment().endOf('week').add(1, 'week').valueOf());
    const [selectedItem, setSelectedItem] = useState(null);
    const [viewMode, setViewMode] = useState('week');
    const [isDragging, setIsDragging] = useState(false);
    const [isLocked, setIsLocked] = useState(false); // Lock state for timeline
    
    // Get project methodology (same logic as Board.jsx)
    const initialMethod = (() => {
        const allowed = Object.values(METHODOLOGIES);
        const fromMeta = project?.meta?.methodology;
        if (allowed.includes(fromMeta)) return fromMeta;
        let fromLocal = null;
        try {
            if (project?.id) {
                fromLocal = localStorage.getItem(`project:${project.id}:methodology`);
            }
        } catch {
            fromLocal = null;
        }
        if (allowed.includes(fromLocal)) return fromLocal;
        return DEFAULT_METHOD;
    })();
    
    const methodology = initialMethod;
    const STATUS_META = getStatusMeta(methodology);
    const STATUS_ORDER = getStatusOrder(methodology);
    
    // Server statuses (canonical)
    const SERVER_STATUSES = ['todo', 'inprogress', 'review', 'done'];
    
    // Method to server mapping (from Board.jsx)
    const METHOD_TO_SERVER = {
        [METHODOLOGIES.KANBAN]: {
            todo: 'todo',
            inprogress: 'inprogress',
            review: 'review',
            done: 'done',
        },
        [METHODOLOGIES.SCRUM]: {
            backlog: 'todo',
            todo: 'todo',
            inprogress: 'inprogress',
            testing: 'review',
            review: 'review',
            done: 'done',
        },
        [METHODOLOGIES.AGILE]: {
            backlog: 'todo',
            todo: 'todo',
            inprogress: 'inprogress',
            testing: 'review',
            review: 'review',
            done: 'done',
        },
        [METHODOLOGIES.WATERFALL]: {
            requirements: 'todo',
            design: 'inprogress',
            implementation: 'inprogress',
            verification: 'review',
            maintenance: 'done',
        },
        [METHODOLOGIES.LEAN]: {
            backlog: 'todo',
            todo: 'inprogress',
            testing: 'review',
            review: 'review',
            done: 'done',
        },
    };
    
    // Server default to method mapping (from Board.jsx)
    const SERVER_DEFAULT_TO_METHOD = {
        [METHODOLOGIES.KANBAN]: {
            todo: 'todo',
            inprogress: 'inprogress',
            review: 'review',
            done: 'done',
        },
        [METHODOLOGIES.SCRUM]: {
            todo: 'todo',
            inprogress: 'inprogress',
            review: 'review',
            done: 'done',
        },
        [METHODOLOGIES.AGILE]: {
            todo: 'todo',
            inprogress: 'inprogress',
            review: 'review',
            done: 'done',
        },
        [METHODOLOGIES.WATERFALL]: {
            todo: 'requirements',
            inprogress: 'design',
            review: 'verification',
            done: 'maintenance',
        },
        [METHODOLOGIES.LEAN]: { 
            todo: 'backlog', 
            inprogress: 'todo', 
            review: 'testing', 
            done: 'done' 
        },
    };
    
    // Build task columns (same logic as Board.jsx buildInitialColumns)
    const tasksByStatus = {};
    const allTasks = [];
    
    // Initialize columns
    STATUS_ORDER.forEach((status) => {
        tasksByStatus[status] = [];
    });
    
    if (tasks && typeof tasks === 'object') {
        SERVER_STATUSES.forEach((serverKey) => {
            const arr = Array.isArray(tasks[serverKey]) ? tasks[serverKey] : [];
            if (!arr.length) return;
            
            const defaultPhase = SERVER_DEFAULT_TO_METHOD[methodology]?.[serverKey] || STATUS_ORDER[0];
            arr.forEach((task) => {
                if (!task) return;
                
                // For Timeline, we don't have phaseMap, so use default phase
                const finalPhase = defaultPhase;
                const taskWithStatus = { ...task, status: finalPhase };
                tasksByStatus[finalPhase].push(taskWithStatus);
                allTasks.push(taskWithStatus);
            });
        });
    }

    // Dynamic groups that update based on current task distribution
    const [groups, setGroups] = useState(() => 
        STATUS_ORDER.map((status) => {
            const meta = STATUS_META[status];
            return {
                id: status,
                title: meta?.title || status,
                rightTitle: '',
                stackItems: true,
                height: Math.max(120, (tasksByStatus[status]?.length || 1) * 50 + 40) // Extra space for stacking
            };
        })
    );

    // Function to calculate optimal height for a status group
    const calculateGroupHeight = useCallback((statusId, taskCount) => {
        // Base height + task space + extra padding for drops
        const baseHeight = 80;
        const taskHeight = 35; // Height per task
        const padding = 60; // Extra space for incoming tasks
        const minHeight = 120;
        
        return Math.max(minHeight, baseHeight + (taskCount * taskHeight) + padding);
    }, []);

    // Function to update group heights dynamically
    const updateGroupHeights = useCallback((currentItems) => {
        // Count tasks per group from current items
        const taskCounts = {};
        STATUS_ORDER.forEach(status => {
            taskCounts[status] = 0;
        });
        
        currentItems.forEach(item => {
            if (taskCounts.hasOwnProperty(item.group)) {
                taskCounts[item.group]++;
            }
        });

        // Update groups with new heights
        setGroups(prevGroups => 
            prevGroups.map(group => ({
                ...group,
                height: calculateGroupHeight(group.id, taskCounts[group.id] || 0)
            }))
        );
    }, [calculateGroupHeight, STATUS_ORDER]);

    // Handle drag preview - expand target group when dragging over it
    const handleItemDrag = useCallback((itemId, dragTime, newGroupOrder) => {
        if (isLocked || !isDragging) return;
        
        // Temporarily expand the target group to show drop space
        const targetGroupId = groups[newGroupOrder]?.id;
        if (targetGroupId) {
            setGroups(prevGroups => 
                prevGroups.map(group => ({
                    ...group,
                    height: group.id === targetGroupId 
                        ? calculateGroupHeight(group.id, (tasksByStatus[group.id]?.length || 0) + 1) // +1 for incoming task
                        : group.height
                }))
            );
        }
    }, [isLocked, isDragging, groups, calculateGroupHeight, tasksByStatus]);

    // Get status color based on methodology
    function getStatusColor(status) {
        const meta = STATUS_META[status];
        if (meta?.accent) {
            return meta.accent;
        }
        // Fallback colors for common statuses
        switch (status) {
            case 'done': return theme.palette.success.main;
            case 'inprogress': return theme.palette.info.main;
            case 'review': return theme.palette.warning.main;
            default: return theme.palette.grey[600];
        }
    }

    function getStatusColorLight(status) {
        const meta = STATUS_META[status];
        if (meta?.accent) {
            return alpha(meta.accent, 0.7);
        }
        // Fallback colors for common statuses
        switch (status) {
            case 'done': return alpha(theme.palette.success.main, 0.7);
            case 'inprogress': return alpha(theme.palette.info.main, 0.7);
            case 'review': return alpha(theme.palette.warning.main, 0.7);
            default: return alpha(theme.palette.grey[600], 0.7);
        }
    }

    // Map tasks to timeline items grouped by status
    const [items, setItems] = useState(
        allTasks.map((task, index) => {
            const startDate = task.start_date ? moment(task.start_date) : moment().startOf('day');
            const endDate = task.end_date ? moment(task.end_date) : startDate.clone().add(1, 'day');
            const finalEndDate = endDate.isBefore(startDate) ? startDate.clone().add(1, 'day') : endDate;

            // Get assignees for avatars
            const assignees = task.assignees || [];
            
            return {
                id: task.id || index,
                group: task.status || 'todo', // Group by status, not individual task
                title: task.title || 'Untitled Task',
                start_time: startDate.valueOf(),
                end_time: finalEndDate.valueOf(),
                canMove: !isLocked,
                canResize: !isLocked ? 'both' : false,
                canChangeGroup: !isLocked, // Allow moving between status groups
                originalTask: task,
                assignees: assignees,
                itemProps: {
                    style: {
                        background: `linear-gradient(135deg, ${getStatusColor(task.status)} 0%, ${getStatusColorLight(task.status)} 100%)`,
                        border: `2px solid ${alpha(getStatusColor(task.status), 0.4)}`,
                        borderRadius: '6px',
                        color: '#ffffff',
                        boxShadow: theme.shadows[2],
                        fontSize: '11px',
                        fontWeight: 500,
                        padding: '6px 10px',
                        cursor: !isLocked ? 'grab' : 'default',
                        transition: 'all 0.2s ease',
                        minHeight: '28px',
                        overflow: 'hidden',
                        textOverflow: 'ellipsis',
                        whiteSpace: 'nowrap'
                    }
                }
            };
        })
    );

    // Update group heights when items change
    useEffect(() => {
        if (items.length > 0) {
            updateGroupHeights(items);
        }
    }, [items, updateGroupHeights]);

    // View mode handlers
    const handleViewModeChange = useCallback((mode) => {
        setViewMode(mode);
        const now = moment();
        let start, end;
        
        switch (mode) {
            case 'day':
                start = now.clone().startOf('day');
                end = now.clone().endOf('day');
                break;
            case 'week':
                start = now.clone().startOf('week');
                end = now.clone().endOf('week').add(1, 'week');
                break;
            case 'month':
                start = now.clone().startOf('month');
                end = now.clone().endOf('month');
                break;
        }
        
        setVisibleTimeStart(start.valueOf());
        setVisibleTimeEnd(end.valueOf());
    }, []);

    // Zoom handlers
    const handleZoomIn = useCallback(() => {
        const zoom = visibleTimeEnd - visibleTimeStart;
        const newZoom = zoom * 0.75;
        const center = (visibleTimeStart + visibleTimeEnd) / 2;
        setVisibleTimeStart(center - newZoom / 2);
        setVisibleTimeEnd(center + newZoom / 2);
    }, [visibleTimeStart, visibleTimeEnd]);

    const handleZoomOut = useCallback(() => {
        const zoom = visibleTimeEnd - visibleTimeStart;
        const newZoom = zoom * 1.25;
        const center = (visibleTimeStart + visibleTimeEnd) / 2;
        setVisibleTimeStart(center - newZoom / 2);
        setVisibleTimeEnd(center + newZoom / 2);
    }, [visibleTimeStart, visibleTimeEnd]);

    // Handle item move with proper backend update  
    const handleItemMove = async (itemId, dragTime, newGroupOrder) => {
        if (isLocked) return;
        
        const newItems = [...items];
        const item = newItems.find(i => i.id === itemId);
        
        if (item && item.originalTask) {
            const oldGroup = item.group;
            const newGroup = groups[newGroupOrder].id;
            const duration = item.end_time - item.start_time;
            const originalStart = item.start_time;
            const originalEnd = item.end_time;
            
            // Update local state immediately for responsive UI
            item.start_time = dragTime;
            item.end_time = dragTime + duration;
            item.group = newGroup;
            setItems(newItems);
            
            // Update group heights to accommodate the moved task
            updateGroupHeights(newItems);
            
            // Prepare update data
            const updateData = {
                start_date: moment(dragTime).format('YYYY-MM-DD'),
                end_date: moment(dragTime + duration).format('YYYY-MM-DD')
            };
            
            // Add status if group changed - map methodology status back to server status
            if (newGroup !== oldGroup) {
                const serverStatus = METHOD_TO_SERVER[methodology]?.[newGroup] || newGroup;
                updateData.status = serverStatus;
            }
            
            // Update in backend using proper route
            try {
                const response = await axios.patch(
                    `/projects/${project.id}/tasks/${item.originalTask.id}`,
                    updateData,
                    {
                        headers: {
                            'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content'),
                            'Accept': 'application/json',
                        }
                    }
                );
                
                console.log('Task updated successfully:', response.data);
            } catch (error) {
                console.error('Failed to update task:', error.response?.data || error);
                
                // Revert on error
                const revertedItems = [...items];
                const revertItem = revertedItems.find(i => i.id === itemId);
                if (revertItem) {
                    revertItem.start_time = originalStart;
                    revertItem.end_time = originalEnd;
                    revertItem.group = oldGroup;
                }
                setItems(revertedItems);
                
                // Show error message
                alert('Failed to update task. Please try again.');
            }
        }
    };

    // Handle item resize with proper backend update
    const handleItemResize = async (itemId, time, edge) => {
        if (isLocked) return;
        
        const newItems = [...items];
        const item = newItems.find(i => i.id === itemId);
        
        if (item && item.originalTask) {
            const originalStart = item.start_time;
            const originalEnd = item.end_time;
            
            // Update local state immediately
            if (edge === 'left') {
                item.start_time = time;
            } else {
                item.end_time = time;
            }
            setItems(newItems);
            
            // Update in backend
            try {
                const response = await axios.patch(
                    `/projects/${project.id}/tasks/${item.originalTask.id}`,
                    {
                        start_date: moment(item.start_time).format('YYYY-MM-DD'),
                        end_date: moment(item.end_time).format('YYYY-MM-DD')
                    },
                    {
                        headers: {
                            'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content'),
                            'Accept': 'application/json',
                        }
                    }
                );
                
                console.log('Task dates updated successfully:', response.data);
            } catch (error) {
                console.error('Failed to update task dates:', error.response?.data || error);
                
                // Revert on error
                const revertedItems = [...items];
                const revertItem = revertedItems.find(i => i.id === itemId);
                if (revertItem) {
                    revertItem.start_time = originalStart;
                    revertItem.end_time = originalEnd;
                }
                setItems(revertedItems);
                
                // Show error message
                alert('Failed to update task dates. Please try again.');
            }
        }
    };
    
    // Toggle lock state
    const toggleLock = () => {
        const newLockState = !isLocked;
        setIsLocked(newLockState);
        
        // Update all items' move/resize capabilities
        const updatedItems = items.map(item => ({
            ...item,

// Zoom handlers
const handleZoomIn = useCallback(() => {
    const zoom = visibleTimeEnd - visibleTimeStart;
    const newZoom = zoom * 0.75;
    const center = (visibleTimeStart + visibleTimeEnd) / 2;
    setVisibleTimeStart(center - newZoom / 2);
    setVisibleTimeEnd(center + newZoom / 2);
}, [visibleTimeStart, visibleTimeEnd]);

const handleZoomOut = useCallback(() => {
    const zoom = visibleTimeEnd - visibleTimeStart;
    const newZoom = zoom * 1.25;
    const center = (visibleTimeStart + visibleTimeEnd) / 2;
    setVisibleTimeStart(center - newZoom / 2);
    setVisibleTimeEnd(center + newZoom / 2);
}, [visibleTimeStart, visibleTimeEnd]);

// Custom item renderer for better stacked task display with tooltips
const itemRenderer = ({ item, itemContext, getItemProps, getResizeProps }) => {
    const backgroundColor = itemContext.selected
        ? alpha(getStatusColor(item.originalTask.status), 0.9)
        : `linear-gradient(135deg, ${getStatusColor(item.originalTask.status)} 0%, ${getStatusColorLight(item.originalTask.status)} 100%)`;
        );
    };

    return (
        <AuthenticatedLayout user={authenticatedUser}>
            <Head title={`${project?.name ?? 'Project'} — Timeline`} />
            
            {/* Custom styles for timeline calendar in dark mode */}
            <style dangerouslySetInnerHTML={{
                __html: `
                .react-calendar-timeline .rct-dateHeader {
                    color: ${theme.palette.mode === 'dark' ? '#ffffff' : '#000000'} !important;
                    background: ${theme.palette.mode === 'dark' ? theme.palette.background.default : '#ffffff'} !important;
                }
                .react-calendar-timeline .rct-dateHeader-primary {
                    color: ${theme.palette.mode === 'dark' ? '#ffffff' : '#000000'} !important;
                    background: ${theme.palette.mode === 'dark' ? theme.palette.background.default : '#ffffff'} !important;
                }
                .react-calendar-timeline .rct-dateHeader .rct-label {
                    color: ${theme.palette.mode === 'dark' ? '#ffffff' : '#000000'} !important;
                }
                    .react-calendar-timeline .rct-horizontal-lines .rct-hl-even,
                    .react-calendar-timeline .rct-horizontal-lines .rct-hl-odd {
                        border-color: ${theme.palette.divider} !important;
                    }
                    .react-calendar-timeline .rct-vertical-lines .rct-vl {
                        border-color: ${theme.palette.divider} !important;
                    }
                `
            }} />

            <Box sx={{ 
                minHeight: '100vh', 
                background: theme.palette.mode === 'dark' 
                    ? theme.palette.background.default 
                    : 'linear-gradient(180deg, #f8fafc 0%, #e2e8f0 100%)'
            }}>
                {/* Header */}
                <Paper 
                    elevation={0}
                    sx={{
                        borderRadius: 0,
                        borderBottom: `1px solid ${theme.palette.divider}`,
                        background: theme.palette.background.paper,
                        position: 'sticky',
                        top: 0,
                        zIndex: 100
                    }}
                >
                    <Box sx={{ 
                        px: 3, 
                        py: 2,
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'space-between'
                    }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                            <Tooltip title="Back to Board">
                                <IconButton
                                    onClick={() => router.visit(route('tasks.index', project.id))}
                                    sx={{
                                        background: alpha(theme.palette.primary.main, 0.1),
                                        '&:hover': {
                                            background: alpha(theme.palette.primary.main, 0.2),
                                        }
                                    }}
                                >
                                    <ArrowBackIcon />
                                </IconButton>
                            </Tooltip>
                            <Box>
                                <Typography variant="h5" sx={{ 
                                    fontWeight: 700,
                                    color: theme.palette.text.primary,
                                }}>
                                    {project?.name || 'Project Timeline'}
                                </Typography>
                                <Box sx={{ display: 'flex', gap: 2, alignItems: 'center' }}>
                                    <Chip 
                                        icon={<ScheduleIcon sx={{ fontSize: 16 }} />}
                                        label={`${allTasks.length} total`}
                                        size="small"
                                        sx={{
                                            background: alpha(theme.palette.info.main, 0.1),
                                            color: theme.palette.info.main,
                                            fontWeight: 600,
                                        }}
                                    />
                                    <Chip
                                        icon={<CheckCircleIcon sx={{ fontSize: 16 }} />}
                                        label={`${allTasks.filter(t => t.status === 'done').length} completed`}
                                        size="small"
                                        sx={{
                                            background: alpha(theme.palette.success.main, 0.1),
                                            color: theme.palette.success.main,
                                            fontWeight: 600,
                                        }}
                                    />
                                </Box>
                            </Box>
                        </Box>

                        {/* Control Panel */}
                        <Box sx={{ display: 'flex', gap: 2, alignItems: 'center' }}>
                            {/* Lock/Unlock Toggle */}
                            <Tooltip title={isLocked ? 'Unlock timeline for editing' : 'Lock timeline to prevent changes'}>
                                <Button
                                    variant={isLocked ? 'contained' : 'outlined'}
                                    color={isLocked ? 'warning' : 'primary'}
                                    size="small"
                                    onClick={toggleLock}
                                    startIcon={isLocked ? <LockIcon /> : <LockOpenIcon />}
                                    sx={{
                                        minWidth: 120,
                                        fontWeight: 600,
                                    }}
                                >
                                    {isLocked ? 'Locked' : 'Unlocked'}
                                </Button>
                            </Tooltip>
                            {/* View Mode Selector */}
                            <ButtonGroup size="small" variant="outlined">
                                <Tooltip title="Day View">
                                    <Button
                                        onClick={() => handleViewModeChange('day')}
                                        variant={viewMode === 'day' ? 'contained' : 'outlined'}
                                    >
                                        <TodayIcon fontSize="small" />
                                    </Button>
                                </Tooltip>
                                <Tooltip title="Week View">
                                    <Button
                                        onClick={() => handleViewModeChange('week')}
                                        variant={viewMode === 'week' ? 'contained' : 'outlined'}
                                    >
                                        <ViewWeekIcon fontSize="small" />
                                    </Button>
                                </Tooltip>
                                <Tooltip title="Month View">
                                    <Button
                                        onClick={() => handleViewModeChange('month')}
                                        variant={viewMode === 'month' ? 'contained' : 'outlined'}
                                    >
                                        <ViewMonthIcon fontSize="small" />
                                    </Button>
                                </Tooltip>
                            </ButtonGroup>

                            {/* Zoom Controls */}
                            <ButtonGroup size="small" variant="outlined">
                                <Tooltip title="Zoom In">
                                    <IconButton onClick={handleZoomIn} size="small">
                                        <ZoomInIcon />
                                    </IconButton>
                                </Tooltip>
                                <Tooltip title="Zoom Out">
                                    <IconButton onClick={handleZoomOut} size="small">
                                        <ZoomOutIcon />
                                    </IconButton>
                                </Tooltip>
                            </ButtonGroup>
                        </Box>
                    </Box>
                </Paper>

                {/* Timeline Container */}
                <Container maxWidth={false} sx={{ py: 3 }}>
                    <Paper
                        elevation={2}
                        sx={{
                            borderRadius: 2,
                            overflow: 'hidden',
                            background: theme.palette.background.paper
                        }}
                    >
                        <Timeline
                            groups={groups}
                            items={items}
                            defaultTimeStart={moment().startOf('week')}
                            defaultTimeEnd={moment().endOf('week').add(1, 'week')}
                            visibleTimeStart={visibleTimeStart}
                            visibleTimeEnd={visibleTimeEnd}
                            onTimeChange={(start, end, updateScrollCanvas) => {
                                if (!isDragging) {
                                    setVisibleTimeStart(start);
                                    setVisibleTimeEnd(end);
                                    updateScrollCanvas(start, end);
                                }
                            }}
                            onItemMove={handleItemMove}
                            onItemResize={handleItemResize}
                            onItemSelect={(itemId) => setSelectedItem(itemId)}
                            onItemDeselect={() => setSelectedItem(null)}
                            lineHeight={50}
                            itemHeightRatio={0.75}
                            canMove={!isLocked}
                            canResize={!isLocked ? 'both' : false}
                            canChangeGroup={!isLocked}
                            stackItems={true}
                            useResizeHandle={true}
                            traditionalZoom={false}
                            minZoom={60 * 60 * 1000}
                            maxZoom={365.24 * 86400 * 1000}
                            sidebarWidth={150}
                            rightSidebarWidth={50}
                            itemTouchSendsClick={false}
                            timeSteps={{
                                second: 1,
                                minute: 1,
                                hour: 1,
                                day: 1,
                                month: 1,
                                year: 1
                            }}
                            dragSnap={15 * 60 * 1000} // 15 minutes for smoother resizing
                            resizeSnap={15 * 60 * 1000} // 15 minutes for resize operations
                            onItemDrag={(itemId, dragTime, newGroupOrder) => {
                                setIsDragging(true);
                                handleItemDrag(itemId, dragTime, newGroupOrder);
                            }}
                            onItemDrop={(item) => setIsDragging(false)}
                            itemRenderer={itemRenderer}
                        >
                            <TimelineHeaders className="timeline-headers">
                                <SidebarHeader>
                                    {({ getRootProps }) => (
                                        <div {...getRootProps()} style={{
                                            background: theme.palette.mode === 'dark' 
                                                ? theme.palette.background.default
                                                : '#f8fafc',
                                            borderBottom: `2px solid ${theme.palette.divider}`,
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            fontWeight: 600,
                                            fontSize: '14px',
                                            color: theme.palette.text.primary,
                                            textTransform: 'uppercase'
                                        }}>
                                            Status
                                        </div>
                                    )}
                                </SidebarHeader>
                                <DateHeader 
                                    unit="primaryHeader"
                                    style={{
                                        background: theme.palette.mode === 'dark'
                                            ? theme.palette.background.default
                                            : '#ffffff'
                                    }}
                                />
                                <DateHeader 
                                    style={{
                                        background: theme.palette.background.paper
                                    }}
                                />
                            </TimelineHeaders>
                        </Timeline>

                        {/* Helper Text */}
                        <Box sx={{ 
                            p: 2, 
                            background: theme.palette.mode === 'dark' 
                                ? alpha(theme.palette.info.main, 0.15)
                                : alpha(theme.palette.info.main, 0.08),
                            borderTop: `1px solid ${theme.palette.divider}`
                        }}>
                            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                <Typography variant="body2" sx={{ 
                                    display: 'flex', 
                                    alignItems: 'center', 
                                    gap: 1,
                                    color: theme.palette.text.primary,
                                    fontWeight: 500,
                                }}>
                                    <DragIndicatorIcon sx={{ fontSize: 18 }} />
                                    {isLocked 
                                        ? 'Timeline is locked. Click unlock button to enable editing.'
                                        : 'Drag tasks to change dates • Resize edges to adjust duration • Drag between rows to change status'
                                    }
                                </Typography>
                                {isLocked && (
                                    <Chip
                                        icon={<LockIcon sx={{ fontSize: 16 }} />}
                                        label="Read-only mode"
                                        color="warning"
                                        size="small"
                                        sx={{ fontWeight: 600 }}
                                    />
                                )}
                            </Box>
                        </Box>
                    </Paper>
                </Container>

                <style dangerouslySetInnerHTML={{
                    __html: `
                        .react-calendar-timeline .rct-sidebar-header {
                            background: ${theme.palette.mode === 'dark' ? theme.palette.background.default : '#f8fafc'};
                            color: ${theme.palette.text.primary};
                        }
                        .react-calendar-timeline .rct-sidebar-row {
                            background: ${theme.palette.mode === 'dark' ? theme.palette.background.paper : '#ffffff'};
                            color: ${theme.palette.text.primary};
                            border-bottom: 1px solid ${theme.palette.divider};
                            font-weight: 500;
                        }
                        .react-calendar-timeline .rct-header-root {
                            background: ${theme.palette.mode === 'dark' ? theme.palette.background.default : '#ffffff'};
                            color: ${theme.palette.text.primary};
                        }
                        .react-calendar-timeline .rct-dateHeader {
                            color: ${theme.palette.mode === 'dark' ? '#ffffff' : '#000000'};
                        }
                        .react-calendar-timeline .rct-item:hover {
                            z-index: 88;
                        }
                        .react-calendar-timeline .rct-items {
                            background: ${theme.palette.mode === 'dark' ? theme.palette.background.default : '#fafbfc'};
                        }
                        .react-calendar-timeline .rct-vertical-lines .rct-vl {
                            stroke: ${theme.palette.divider};
                        }
                        .react-calendar-timeline .rct-horizontal-lines {
                            stroke: ${theme.palette.divider};
                        }
                        .react-calendar-timeline .rct-calendar-header {
                            border: 1px solid ${theme.palette.divider};
                        }
                    `
                }} />
            </Box>
        </AuthenticatedLayout>
    );
}
